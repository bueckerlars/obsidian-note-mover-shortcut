import * as fs from 'fs';
import * as path from 'path';

interface ChangelogEntry {
  version: string;
  changes: {
    features?: string[];
    bugFixes?: string[];
    improvements?: string[];
    changes?: string[];
    fixes?: string[];
    performance?: string[];
  };
}

function parseChangelog(content: string): ChangelogEntry[] {
  const entries: ChangelogEntry[] = [];
  const lines = content.split('\n');

  let currentVersion = '';
  let currentChanges: ChangelogEntry['changes'] = {};
  let currentSection:
    | 'features'
    | 'bugFixes'
    | 'improvements'
    | 'changes'
    | 'fixes'
    | 'performance'
    | null = null;

  for (const line of lines) {
    // Recognize version header (e.g. "## [0.2.1]" or "## [0.1.6]")
    const versionMatch = line.match(/^##\s*\[?(\d+\.\d+\.\d+)\]?/);
    if (versionMatch) {
      // Save previous version if exists
      if (currentVersion) {
        entries.push({
          version: currentVersion,
          changes: { ...currentChanges },
        });
      }

      // Start new version
      currentVersion = versionMatch[1];
      currentChanges = {};
      currentSection = null;
      continue;
    }

    // Recognize section headers
    if (line.startsWith('### Features')) {
      currentSection = 'features';
      currentChanges.features = [];
      continue;
    }
    if (line.startsWith('### Bug Fixes')) {
      currentSection = 'bugFixes';
      currentChanges.bugFixes = [];
      continue;
    }
    if (line.startsWith('### Improvements')) {
      currentSection = 'improvements';
      currentChanges.improvements = [];
      continue;
    }
    if (line.startsWith('### Changes')) {
      currentSection = 'changes';
      currentChanges.changes = [];
      continue;
    }
    if (line.startsWith('### Fixes')) {
      currentSection = 'fixes';
      currentChanges.fixes = [];
      continue;
    }
    if (line.startsWith('### Performance')) {
      currentSection = 'performance';
      currentChanges.performance = [];
      continue;
    }

    // Collect changelog entries
    if (currentSection && line.startsWith('- ')) {
      const changeText = line.substring(2).trim();
      if (changeText) {
        currentChanges[currentSection]?.push(changeText);
      }
    }
  }

  // Save last version
  if (currentVersion) {
    entries.push({
      version: currentVersion,
      changes: { ...currentChanges },
    });
  }

  return entries;
}

function generateChangelogFile(entries: ChangelogEntry[]): string {
  return `// This file is auto-generated by scripts/generate-changelog.ts
// Do not edit manually - changes will be overwritten

export interface ChangelogEntry {
  version: string;
  changes: {
    features?: string[];
    bugFixes?: string[];
    improvements?: string[];
    changes?: string[];
    fixes?: string[];
    performance?: string[];
  };
}

export const CHANGELOG_ENTRIES: ChangelogEntry[] = ${JSON.stringify(entries, null, 2)};
`;
}

async function main() {
  try {
    const changelogPath = path.join(__dirname, '..', 'CHANGELOG.md');
    const outputPath = path.join(
      __dirname,
      '..',
      'src',
      'generated',
      'changelog.ts'
    );

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Read changelog file
    const changelogContent = fs.readFileSync(changelogPath, 'utf-8');

    // Parse changelog
    const entries = parseChangelog(changelogContent);

    // Generate TypeScript file
    const generatedContent = generateChangelogFile(entries);

    // Write generated file
    fs.writeFileSync(outputPath, generatedContent);

    console.log(
      `✅ Generated changelog with ${entries.length} entries at ${outputPath}`
    );
  } catch (error) {
    console.error('❌ Error generating changelog:', error);
    process.exit(1);
  }
}

main();
